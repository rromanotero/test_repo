# This is a basic workflow that is manually triggered

name: Package Services

# Controls when the action will run. Workflow runs when manually triggered using the UI
# or API.
on:
  push:

# A workflow run is made up of one or more jobs that can run sequentially or in parallel
jobs:
  build_and_publish:
    # The type of runner that the job will run on
    runs-on: ubuntu-latest
    env:
      DOCKER_USERNAME: ${{ secrets.DOCKER_USERNAME }}
      DOCKER_PASSWORD: ${{ secrets.DOCKER_PASSWORD }}
      TARGET_PLATFORM: linux/arm/v7


    # Steps represent a sequence of tasks that will be executed as part of the job
    steps:
    - name: Checkout the code
      uses: actions/checkout@v1
    - name: Set up Docker Buildx
      uses: crazy-max/ghaction-docker-buildx@v1
      with:
        version: latest
    - name: Docker Login
      if: success()
      run: |
        echo "${DOCKER_PASSWORD}" | docker login ${DOCKER_REGISTRY} --username "${DOCKER_USERNAME}" --password-stdin
    - name: Detect Services
      if: success()
      env:
        ACTIONS_ALLOW_UNSECURE_COMMANDS: 'true'
      run: |
        SERVICES_PATH=./services
        echo "SERVICES_PATH="$SERVICES_PATH
        echo ""

        if [ ! -d $SERVICES_PATH ]; then
          echo "services directory missing: "$SERVICES_PATH
          exit 1
        fi

        services_found=()
        for path in $SERVICES_PATH/*; do
          if [[ -d $path ]]; then
            SERVICE_NAME=$(basename $path)
            SVC_PATH=$SERVICES_PATH/$SERVICE_NAME

            echo "Checking $SVC_PATH"

            if [ ! -f $SVC_PATH/Dockerfile ]; then
              echo "service $SERVICE_NAME is missing its Dockerfile"
              echo "here's the contents of $SVC_PATH"
              ls -l $SVC_PATH
              exit 1
            fi

            echo "found service "$SERVICE_NAME
            services_found+=("$SERVICE_NAME")
          fi
        done

        if [ ${#services_found[@]} -eq 0 ]; then
          echo "no services found in ./services"
          exit 1
        else
          num_of_services_found="${#services_found[@]}"
          echo ""
          echo "found a total of "$num_of_services_found" services"
        fi

        function join_by {
          local d=${1-} f=${2-}; if shift 2; then printf %s "$f" "${@/#/$d}"; fi;
        }

        comma_separated_services_found=$(join_by , "${services_found[@]}")
        echo $comma_separated_services_found

        echo "::set-env name=comma_separated_services_found::$comma_separated_services_found"


    - name: Run Buildx (push image)
      if: success()
      run: |
        BRANCH_NAME=${GITHUB_REF##*/}
        PROJECT_NAME=${GITHUB_REPOSITORY##*/}
        ACCOUNT_OWNER=$(echo $GITHUB_REPOSITORY | cut -d/ -f1)

        echo "TARGET_PLATFORM="$TARGET_PLATFORM
        echo "GITHUB_REF="$GITHUB_REF
        echo "BRANCH_NAME="$BRANCH_NAME
        echo "GITHUB_SHA="$GITHUB_SHA
        echo "GITHUB_REPOSITORY="$GITHUB_REPOSITORY
        echo "ACCOUNT_OWNER="$ACCOUNT_OWNER
        echo "PROJECT_NAME"=$PROJECT_NAME
        echo "comma_separated_services_found="$comma_separated_services_found

        IFS=',' read -r -a services_found <<< "$comma_separated_services_found"

        for service_name in "${services_found[@]}"
        do
          IMAGE_NAME=$ACCOUNT_OWNER'/'$PROJECT_NAME'_'$service_name:$BRANCH_NAME
          SERVICE_PATH=services/$service_name
          echo '----------------------------------------------------------'
          echo 'Publishing image '$IMAGE_NAME' from path '$SERVICE_PATH
          echo '----------------------------------------------------------'
          cd services/$service_name
          docker buildx build \
            --platform  $TARGET_PLATFORM \
            --tag $IMAGE_NAME \
            --file ./Dockerfile \
            --output type=image,push=true .
          cd ../..
        done

  #################
  #################

  upgrade_helm_app_version:
    runs-on: ubuntu-latest
    steps:
    - name: Checkout Helm Chart repo
      uses: actions/checkout@master
      with:
        repository: ${{ github.repository }}_cd
        ref: ${{ github.ref }}
        persist-credentials: false # otherwise, the token used is the GITHUB_TOKEN, instead of your personal access token.
        fetch-depth: 0 # otherwise, there would be errors pushing refs to the destination repository.
    - name: Detect Charts
      if: success()
      env:
        ACTIONS_ALLOW_UNSECURE_COMMANDS: 'true'
      run: |
        SERVICES_PATH=./services
        echo "SERVICES_PATH="$SERVICES_PATH
        echo ""

        if [ ! -d $SERVICES_PATH ]; then
          echo "services directory missing: "$SERVICES_PATH
          exit 1
        fi

        charts_found=()
        for path in $SERVICES_PATH/*; do
          if [[ -d $path ]]; then
            SERVICE_NAME=$(basename $path)
            SVC_PATH=$SERVICES_PATH/$SERVICE_NAME

            echo "Checking $SVC_PATH"

            if [ ! -f $SVC_PATH/Chart.yaml ]; then
              echo "service $SERVICE_NAME is missing its Chart.yaml"
              echo "here's the contents of $SVC_PATH"
              ls -l $SVC_PATH
              exit 1
            fi

            echo "found service "$SERVICE_NAME
            charts_found+=("$SERVICE_NAME")
          fi
        done

        if [ ${#charts_found[@]} -eq 0 ]; then
          echo "no charts found in ./services"
          exit 1
        else
          num_of_charts_found="${#charts_found[@]}"
          echo ""
          echo "found a total of "$num_of_charts_found" charts"
        fi

        function join_by {
          local d=${1-} f=${2-}; if shift 2; then printf %s "$f" "${@/#/$d}"; fi;
        }

        comma_separated_charts_found=$(join_by , "${charts_found[@]}")
        echo $comma_separated_charts_found

        echo "::set-env name=comma_separated_charts_found::$comma_separated_charts_found"
    - name: Upgrade app version
      if: success()
      run: |
        GITHUB_REPOSITORY_CHARTS=$GITHUB_REPOSITORY_cd
        PROJECT_NAME=${GITHUB_REPOSITORY_CHARTS##*/}
        ACCOUNT_OWNER=$(echo $GITHUB_REPOSITORY | cut -d/ -f1)
        BRANCH_NAME=${GITHUB_REF##*/}
        APP_VERSION=$BRANCH_NAME'-'$GITHUB_SHA


        IFS=',' read -r -a charts_found <<< "$comma_separated_charts_found"

        echo "GITHUB_REPOSITORY_CHARTS="$GITHUB_REPOSITORY_CHARTS
        echo "BRANCH_NAME="$BRANCH_NAME
        echo "GITHUB_SHA="$GITHUB_SHA
        echo "APP_VERSION="$APP_VERSION

        echo "comma_separated_charts_found="$comma_separated_charts_found

        CHART_TEMPLATE_PATH=../chart_template.yaml
        cat >$CHART_TEMPLATE_PATH<<EOL
        apiVersion: v2
        name: _APP_NAME_
        description: A Helm chart for Kubernetes

        type: application
        version: 1.0.0
        appVersion: _APP_VERSION_
        EOL

        for chart_name in "${charts_found[@]}"
        do
          sleep 1 ## so logs are not as out of order

          CHART_PATH=services/$chart_name/Chart.yaml

          echo '--------------------------------'
          echo 'Upgrading app '$chart_name

          APP_NAME=$(echo "$chart_name" | tr '_' '-')

          cp $CHART_TEMPLATE_PATH $CHART_PATH

          sed -i "s|_APP_NAME_|$APP_NAME|g" $CHART_PATH
          sed -i "s|_APP_VERSION_|$APP_VERSION|g" $CHART_PATH

          echo '|||| chart contents ||||'
          cat $CHART_PATH
          echo '|||| chart contents ||||'
          echo '--------------------------------'
        done

        git config --global hub.protocol https
        git config --global user.email "41898282+github-actions[bot]@users.noreply.github.com"
        git config --global user.name "github-actions[bot]"

        git add . && git commit -m "app upgrade to "$APP_VERSION
    - name: Push changes
      uses: ad-m/github-push-action@master
      with:
        github_token: ${{ github.token }}
        branch: ${{ github.ref }}
